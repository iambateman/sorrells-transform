<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Sine Wave Visualization</title>
    <style>
      body { 
        margin: 0; 
        padding: 0; 
        overflow: hidden;
        background: #000;
      }
      canvas { 
        width: 100%; 
        height: 100%; 
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 14px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
    <script src="./THREE.MeshLine.js"></script>
  </head>
  <body>
    <div id="info">
      Sine Wave Visualization<br>
      Click and drag to rotate view
    </div>
    <script>
      let scene, camera, renderer;
      let sineWaveLine;
      let time = 0;
      
      const amplitude = 2;
      const frequency = 1;
      const wavelength = 10;
      const points = 200;
      
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 0, 0);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        createSineWave();
        
        createGrid();
        
        createAxes();
        
        setupMouseControls();
        
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function createSineWave() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(points * 3);
        
        for (let i = 0; i < points; i++) {
          const x = (i / (points - 1)) * wavelength - wavelength / 2;
          const y = 0;
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = 0;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({ 
          color: 0x00ff00,
          linewidth: 2
        });
        
        sineWaveLine = new THREE.Line(geometry, material);
        scene.add(sineWaveLine);
      }
      
      function updateSineWave() {
        const positions = sineWaveLine.geometry.attributes.position.array;
        
        for (let i = 0; i < points; i++) {
          const x = (i / (points - 1)) * wavelength - wavelength / 2;
          const y = amplitude * Math.sin((x * frequency * 2 * Math.PI / wavelength) + time);
          positions[i * 3 + 1] = y;
        }
        
        sineWaveLine.geometry.attributes.position.needsUpdate = true;
      }
      
      function createGrid() {
        const size = 20;
        const divisions = 20;
        const gridHelper = new THREE.GridHelper(size, divisions, 0x444444, 0x222222);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
      }
      
      function createAxes() {
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
      }
      
      function setupMouseControls() {
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let rotationX = 0;
        let rotationY = 0;
        
        document.addEventListener('mousedown', (event) => {
          mouseDown = true;
          mouseX = event.clientX;
          mouseY = event.clientY;
        });
        
        document.addEventListener('mouseup', () => {
          mouseDown = false;
        });
        
        document.addEventListener('mousemove', (event) => {
          if (!mouseDown) return;
          
          const deltaX = event.clientX - mouseX;
          const deltaY = event.clientY - mouseY;
          
          targetRotationY += deltaX * 0.01;
          targetRotationX += deltaY * 0.01;
          
          mouseX = event.clientX;
          mouseY = event.clientY;
        });
        
        function updateRotation() {
          rotationX += (targetRotationX - rotationX) * 0.05;
          rotationY += (targetRotationY - rotationY) * 0.05;
          
          camera.position.x = Math.sin(rotationY) * 15;
          camera.position.z = Math.cos(rotationY) * 15;
          camera.position.y = 5 + Math.sin(rotationX) * 10;
          camera.lookAt(0, 0, 0);
        }
        
        const originalAnimate = animate;
        animate = function() {
          updateRotation();
          originalAnimate();
        };
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        time += 0.05;
        updateSineWave();
        
        renderer.render(scene, camera);
      }
      
      init();
      animate();
    </script>
  </body>
</html>